/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 kamar.glb -t 
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useHelper } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";
import { useCursorFollower } from "./providers/CursorFollowerProvider";
import { animate, useMotionValue, useTransform } from "framer-motion";
import { useControls } from "leva";

type GLTFResult = GLTF & {
  nodes: {
    Cube001: THREE.Mesh;
    Cube001_1: THREE.Mesh;
    ["trash-can"]: THREE.Mesh;
    Cube028: THREE.Mesh;
    Cube028_1: THREE.Mesh;
    Plane002: THREE.Mesh;
    Plane002_1: THREE.Mesh;
    ["external-keyboard"]: THREE.Mesh;
    pillow: THREE.Mesh;
    Cube110: THREE.Mesh;
    Cube110_1: THREE.Mesh;
    lamp: THREE.Mesh;
    Cube: THREE.Mesh;
    Cube_1: THREE.Mesh;
    Cube119: THREE.Mesh;
    Cube119_1: THREE.Mesh;
    table: THREE.Mesh;
    Cylinder010: THREE.Mesh;
    Cylinder010_1: THREE.Mesh;
    Cube012: THREE.Mesh;
    Cube012_1: THREE.Mesh;
    Cube121: THREE.Mesh;
    Cube121_1: THREE.Mesh;
    Cube121_2: THREE.Mesh;
    Cube121_3: THREE.Mesh;
    Cube033: THREE.Mesh;
    Cube033_1: THREE.Mesh;
    Cylinder018: THREE.Mesh;
    Cylinder018_1: THREE.Mesh;
    Cylinder018_2: THREE.Mesh;
  };
  materials: {
    chair: THREE.MeshStandardMaterial;
    ["drawing-closer"]: THREE.MeshStandardMaterial;
    wood: THREE.MeshStandardMaterial;
    zee: THREE.MeshStandardMaterial;
    base: THREE.MeshStandardMaterial;
    pillow: THREE.MeshStandardMaterial;
    coding: THREE.MeshStandardMaterial;
    wallpaper: THREE.MeshStandardMaterial;
    bed: THREE.MeshStandardMaterial;
    cupboard: THREE.MeshStandardMaterial;
    light: THREE.MeshStandardMaterial;
    season: THREE.MeshStandardMaterial;
    xaviera: THREE.MeshStandardMaterial;
    darken: THREE.MeshStandardMaterial;
  };
  // animations: GLTFAction[]
};

interface Focus {
  positionX: number;
  positionY: number;
  positionZ: number;
  lookAtX: number;
  lookAtY: number;
  lookAtZ: number;
}

const defaultFocus: Focus = {
  positionX: 15,
  positionY: 5,
  positionZ: -15,
  lookAtX: -4,
  lookAtY: 5,
  lookAtZ: 4,
};

export default function Room(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/model/room.glb") as GLTFResult;

  const { setContent } = useCursorFollower();

  const chairRef = useRef<THREE.Group>(null);

  const [isFocus, setIsFocus] = useState<THREE.Mesh | false>(false);

  const positionX = useMotionValue(defaultFocus.positionX);
  const positionY = useMotionValue(defaultFocus.positionY);
  const positionZ = useMotionValue(defaultFocus.positionZ);
  const lookAtX = useMotionValue(defaultFocus.lookAtX);
  const lookAtY = useMotionValue(defaultFocus.lookAtY);
  const lookAtZ = useMotionValue(defaultFocus.lookAtZ);
  const scrollValue = useMotionValue(0);
  const scrollTransformValue = useTransform(scrollValue, [0, 1], [0, 5]);
  const mouseX = useMotionValue(0);
  const mouseY = useMotionValue(0);

  const easeOutQuad = (t: number) => t * (2 - t);
  const duration = 3;

  useFrame(({ camera, clock }) => {
    const elapsedTime = clock.getElapsedTime();

    camera.position.x = positionX.get();
    camera.position.y = positionY.get() + -scrollTransformValue.get();
    camera.position.z = positionZ.get();
    camera.lookAt(
      new THREE.Vector3(
        lookAtX.get() + -mouseX.get() * 2,
        lookAtY.get() + scrollTransformValue.get() * 0.5 + -mouseY.get() * 2,
        lookAtZ.get() + -mouseX.get() * 2
      )
    );

    if (elapsedTime <= duration) {
      const progress = elapsedTime / duration;
      const easedProgress = easeOutQuad(progress);
      if (chairRef.current) {
        chairRef.current.position.x = 1 * easedProgress;
        chairRef.current.rotation.y = -Math.PI * 1.5 * easedProgress;
      }
    }
  });

  const setDefaultFocus = () => {
    animate(positionX, defaultFocus.positionX);
    animate(positionY, defaultFocus.positionY);
    animate(positionZ, defaultFocus.positionZ);
    animate(lookAtX, defaultFocus.lookAtX);
    animate(lookAtY, defaultFocus.lookAtY);
    animate(lookAtZ, defaultFocus.lookAtZ);
  };

  const handlePointerMove = (e: PointerEvent) => {
    animate(mouseX, (e.clientX / innerWidth) * 2 - 1, {
      duration: 1,
      ease: "circOut",
    });
    animate(mouseY, (e.clientY / innerHeight) * 2 - 1, {
      duration: 1,
      ease: "circOut",
    });
  };

  const handleScrollEvent = () => {
    scrollValue.set(scrollY / innerHeight);
  };

  useEffect(() => {
    window.addEventListener("scroll", handleScrollEvent);
    window.addEventListener("pointermove", handlePointerMove);

    return () => {
      window.removeEventListener("pointermove", handlePointerMove);
      window.removeEventListener("scroll", handleScrollEvent);
    };
  });

  // @ts-ignore : unexpected error
  useHelper(chairRef, THREE.BoxHelper, "green");

  return (
    <group {...props} dispose={null}>
      <group
        position={[-3.49, 3.81, -0.853]}
        rotation={[0, -0.502, 0]}
        scale={[0.024, 0.63, 1.041]}
      >
        <mesh geometry={nodes.Cube001.geometry} material={materials.chair} />
        <mesh
          geometry={nodes.Cube001_1.geometry}
          material={materials["drawing-closer"]}
        />
      </group>
      <mesh
        geometry={nodes["trash-can"].geometry}
        material={materials.chair}
        position={[-3.649, 0.844, -4.11]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.853, 0.853, 0.355]}
      />

      {/* zee */}
      <group
        position={[-4.077, 6.624, -3.699]}
        rotation={[-Math.PI, 0, Math.PI / 2]}
        scale={[1.517, 0.105, 0.791]}
      >
        <mesh geometry={nodes.Cube028.geometry} material={materials.wood} />
        <mesh
          geometry={nodes.Cube028_1.geometry}
          material={materials.zee}
          onPointerEnter={() => setContent("Zee")}
          onPointerLeave={() => setContent("")}
          onClick={() => {
            setDefaultFocus();
            if (isFocus !== nodes.Cube028_1) {
              setIsFocus(nodes.Cube028_1);
              animate(positionY, nodes.Cube028_1.parent?.position.y!);
              animate(positionZ, nodes.Cube028_1.parent?.position.z!);
              animate(lookAtX, nodes.Cube028_1.parent?.position.x!);
              animate(lookAtY, nodes.Cube028_1.parent?.position.y!);
              animate(lookAtZ, nodes.Cube028_1.parent?.position.z!);
            } else {
              setIsFocus(false);
            }
          }}
        >
          <meshStandardMaterial {...materials.zee} emissiveIntensity={0.1} />
        </mesh>
      </group>

      {/* chair */}
      <group
        ref={chairRef}
        position={[0, 1.581, 1.765]}
        rotation={[0, 0, 0]}
        scale={[3.529, 3.361, 2.926]}
      >
        <mesh geometry={nodes.Plane002.geometry} material={materials.chair} />
        <mesh geometry={nodes.Plane002_1.geometry} material={materials.base} />
      </group>
      <mesh
        geometry={nodes["external-keyboard"].geometry}
        material={materials.chair}
        position={[-2.567, 3.098, 1.241]}
        rotation={[1.571, 0.004, -1.571]}
        scale={[-0.089, -0.027, -0.004]}
      />
      <mesh
        geometry={nodes.pillow.geometry}
        material={materials.pillow}
        position={[5.274, 1.325, 2.942]}
        rotation={[-0.431, 0, 0]}
        scale={[1.297, 0.075, 1.042]}
      />

      {/* main laptop */}
      <group
        position={[-3.767, 3.5, 1.259]}
        rotation={[1.571, -0.636, 1.571]}
        scale={[0.05, 0.051, 0.036]}
        onPointerEnter={() => setContent("Laptop")}
        onPointerLeave={() => setContent("")}
        onClick={() => {
          setDefaultFocus();
          if (isFocus !== nodes.Cube110_1) {
            setIsFocus(nodes.Cube110_1);
            animate(positionZ, 1.259);
            animate(positionX, 1.5);
            animate(lookAtX, -3.767);
            animate(lookAtY, 4);
            animate(lookAtZ, 1.259);
          } else {
            setIsFocus(false);
          }
        }}
      >
        <mesh geometry={nodes.Cube110.geometry} material={materials.chair} />
        <mesh geometry={nodes.Cube110_1.geometry} material={materials.coding} />
      </group>
      <mesh
        geometry={nodes.lamp.geometry}
        material={materials.base}
        position={[-3.921, 6.971, 0.925]}
        scale={[0.266, 0.222, 2.44]}
      />
      <group position={[1.298, 5.98, -1.473]} scale={[11.04, 0.114, 11.89]}>
        <mesh geometry={nodes.Cube.geometry} material={materials.base} />
        <mesh geometry={nodes.Cube_1.geometry} material={materials.wallpaper} />
      </group>
      <group
        position={[5.268, 0.857, 0.837]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.399, 0.154, 0.791]}
      >
        <mesh geometry={nodes.Cube119.geometry} material={materials.wood} />
        <mesh geometry={nodes.Cube119_1.geometry} material={materials.bed} />
      </group>
      <mesh
        geometry={nodes.table.geometry}
        material={materials.wood}
        position={[-3.004, 2.266, 0.241]}
        scale={[1.023, 1.339, 0.653]}
      />
      <group
        position={[-3.232, 3.911, 3.218]}
        rotation={[0, 0.997, 0]}
        scale={[0.058, 0.323, 0.058]}
      >
        <mesh
          geometry={nodes.Cylinder010.geometry}
          material={materials.chair}
        />
        <mesh
          geometry={nodes.Cylinder010_1.geometry}
          material={materials["drawing-closer"]}
        />
      </group>
      <group
        position={[-3.012, 3.609, -6.658]}
        rotation={[-Math.PI, 0, 0]}
        scale={[-0.07, -3.497, -0.909]}
      >
        <mesh geometry={nodes.Cube012.geometry} material={materials.wood} />
        <mesh
          geometry={nodes.Cube012_1.geometry}
          material={materials.cupboard}
        />
      </group>

      {/* playlist */}
      <group
        position={[1.362, 6.55, 4.02]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.6, 0.105, 0.716]}
      >
        <mesh geometry={nodes.Cube121.geometry} material={materials.wood} />
        <mesh geometry={nodes.Cube121_1.geometry} material={materials.light}>
          <meshStandardMaterial {...materials.light} emissiveIntensity={0.1} />
        </mesh>
        <mesh geometry={nodes.Cube121_2.geometry} material={materials.season}>
          <meshStandardMaterial {...materials.season} emissiveIntensity={0.1} />
        </mesh>
        <mesh
          geometry={nodes.Cube121_3.geometry}
          material={materials.xaviera}
          onPointerEnter={() => setContent("Xaviera")}
          onPointerLeave={() => setContent("")}
          onClick={() => {
            setDefaultFocus();
            if (isFocus !== nodes.Cube121_3) {
              setIsFocus(nodes.Cube121_3);
              animate(positionY, nodes.Cube121_3.parent?.position.y!);
              animate(positionX, nodes.Cube121_3.parent?.position.x!);
              animate(lookAtX, nodes.Cube121_3.parent?.position.x!);
              animate(lookAtY, nodes.Cube121_3.parent?.position.y!);
              animate(lookAtZ, nodes.Cube121_3.parent?.position.z!);
            } else {
              setIsFocus(false);
            }
          }}
        >
          <meshStandardMaterial
            {...materials.xaviera}
            emissiveIntensity={0.1}
          />
        </mesh>
      </group>
      <group
        position={[6.298, 4.754, 4.098]}
        rotation={[-Math.PI, 0, 0]}
        scale={[-0.075, -0.123, -0.02]}
      >
        <mesh geometry={nodes.Cube033.geometry} material={materials.darken} />
        <mesh geometry={nodes.Cube033_1.geometry} material={materials.base} />
      </group>
      <group position={[-2.914, 3.285, -2.153]} scale={[0.324, 0.042, 0.324]}>
        <mesh geometry={nodes.Cylinder018.geometry} material={materials.base} />
        <mesh
          geometry={nodes.Cylinder018_1.geometry}
          material={materials.pillow}
        />
        <mesh
          geometry={nodes.Cylinder018_2.geometry}
          material={materials.wood}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/model/room.glb");
